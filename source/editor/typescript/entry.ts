import WICK, { RuntimeComponent, Presets, WickRuntime, ExtendedComponent } from "@candlefw/wick";

import * as ACTIONS from "./actions/action.js";

import { initSystem, CreateTimeStamp, GetElapsedTimeSinceStamp } from "./system.js";
import { START_ACTION, APPLY_ACTION } from "./action_initiators.js";
import * as common from "./common_functions.js";
import { initializeEvents } from "./event.js";
import { FlameSystem } from "./types/flame_system.js";



async function initializeHarness(wick: typeof WICK): Promise<ExtendedComponent> {
    return await wick("/flame/editor/components/harness.wick");
}

function extractIFrameContentAndPlaceIntoHarness(
    system: FlameSystem,
    harness_component: ExtendedComponent,
    captive_window: Window,
    edited_presets: Presets
) {
    //Pull out the content of the app and place into a harness component
    const
        //Every new component will be placed in its own harness, which is used to 
        //represent the component's window and document context.
        root_component: RuntimeComponent =
            (<Element & { wick_component: RuntimeComponent; }>
                captive_window.document.querySelector("[w\\3A c]"))
                .wick_component;

    system.edited_components.components = [{ comp: root_component.name }];

    const ele = document.querySelector("iframe");
    document.body.removeChild(ele);
    root_component.destructor();

    const harness = new (harness_component.class_with_integrated_css)(
        system.edited_components,
        undefined,
        undefined,
        undefined,
        undefined,
        edited_presets
    );

    window.document.body.appendChild(harness.ele);
    //root_component.par = harness;
    ////harness.onModelUpdate();
    //
    system.edit_view = harness.ele;
    system.edit_view.style.transformOrigin = "top left";
    //
}
export default async function initFlame(editor_cfw, edited_cfw, edited_window: Window) { //For Isolation

    const
        load_start = CreateTimeStamp(),
        component_map = new Map,
        edited_wick = edited_cfw.wick,
        editor_rt: WickRuntime = editor_cfw.wick.rt,
        editor_wick: typeof WICK = editor_cfw.wick,
        edited_css = edited_window.document.createElement("style"),
        system = initSystem(edited_wick, editor_wick, edited_css, edited_window),
        { event_intercept_frame: event_intercept_ele } = system.ui;



    //Turn off cursor events for the edited elements
    edited_window.document.body.style.pointerEvents = "none";

    let ui_root: RuntimeComponent = <RuntimeComponent>{};

    //Root UI element in document markup.

    /**
     * Integrate Flame editing system into every component instance. 
     */
    edited_cfw.wick.rt.OVERRIDABLE_onComponentCreate = function (comp) {

        //Register all components within a tracker based on their instance type. 
        if (component_map.has(comp.name) == false) component_map.set(comp.name, new Set);
        component_map.get(comp.name).add(comp);

        //Used to trace elements back to their components.
        if (comp.ele) comp.ele.wick_component = comp;
    };

    //LOAD PRESETS -----------------------------------------------------

    //MODELS
    editor_rt.presets.models["flame-editor"] = system.editor_model;
    editor_rt.presets.models["edited-components"] = system.edited_components;

    //API
    editor_rt.presets.api.APPLY_ACTION = APPLY_ACTION;
    editor_rt.presets.api.START_ACTION = START_ACTION;
    editor_rt.presets.api.ACTIONS = ACTIONS;
    editor_rt.presets.api.sys = system;
    Object.assign(editor_rt.presets.api, common);

    const wick_load_start = CreateTimeStamp();

    //ALLOW DEBUGGING ON EDITOR COMPONENTS
    //editor_rt.presets.options.GENERATE_SOURCE_MAPS = true;
    editor_rt.presets.options.REMOVE_DEBUGGER_STATEMENTS = false;


    //LOAD EDITOR COMPONENT -----------------------------------------------------


    const editor_frame = await (editor_wick("/flame/editor/components/editor.wick"));

    extractIFrameContentAndPlaceIntoHarness(
        system,
        await initializeHarness(editor_wick),
        edited_window,
        edited_wick.rt.presets
    );

    system.metrics.ui_components_load_time = GetElapsedTimeSinceStamp(wick_load_start);

    //DO NOT DEBUG ON COMPONENTS GENERATED BY EDITING
    editor_rt.presets.options.GENERATE_SOURCE_MAPS = false;
    editor_rt.presets.options.REMOVE_DEBUGGER_STATEMENTS = true;

    ui_root = (new (editor_frame.class_with_integrated_css)());

    ui_root.appendToDOM(document.body, <HTMLElement>document.body.firstElementChild);

    //PREPARE WINDOW & EVENTS -----------------------------------------------------

    initializeEvents(system, window);

    //

    console.log(
        `%ccfw.FLAME
%cFlaming since 2020 baby!     -     Anthony Weathersby Â©2020     -    \nWARNING: USE DEBUGGING TOOLS AT YOUR OWN RISK. \n DON'T MAKE US SAY WE TOLD YOU SO%c\n jobs@js.candle-smith.com`,
        "color:red; font-size:4em; padding:5px 5px 5px 0; width:100%",
        "background:red; color:white; font-weight:800; font-family:Arial; font-size:1em; padding:10px; width:950px; display:inline-block",
        ""
    );

    system.metrics.startup_time = GetElapsedTimeSinceStamp(load_start);

    if (/*show startup metrics */1) {
        const fmt = (t) => Math.round(t);
        console.log(
            `Loading Information:
    Load Time: 
        ${fmt(system.metrics.startup_time)} ms
    UI Component Parse and Load Time:
        ${fmt(system.metrics.ui_components_load_time)} ms
`
        );
    }
}
